<!doctype html><html lang=en dir=auto><head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Useful Powershell Snippits to Create Custom Installers/Uninstallers | </title><meta name=keywords content><meta name=description content="The Basics The following code snippets are useful for creating custom installers and uninstallers in Powershell. The advantage to creating script installers versus uploading a regular exe or msi is that a script installer allows for fine-grained control over the installation process. This is especially useful when dealing with porly written installers.
At the end of this article, I will provide an exaple of a full script that can be used to install/uninstall a program."><meta name=author content><link rel=canonical href=//localhost:1313/posts/sccm_powershell/><link crossorigin=anonymous href=/assets/css/stylesheet.9464d7dce799270fb154f92b272bb24a1c487917efe0e85ae972d64ddb2ea63b.css integrity="sha256-lGTX3OeZJw+xVPkrJyuyShxIeRfv4Oha6XLWTdsupjs=" rel="preload stylesheet" as=style><link rel=icon href=//localhost:1313/favicon.ico><link rel=icon type=image/png sizes=16x16 href=//localhost:1313/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=//localhost:1313/favicon-32x32.png><link rel=apple-touch-icon href=//localhost:1313/apple-touch-icon.png><link rel=mask-icon href=//localhost:1313/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=//localhost:1313/posts/sccm_powershell/><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><meta property="og:title" content="Useful Powershell Snippits to Create Custom Installers/Uninstallers"><meta property="og:description" content="The Basics The following code snippets are useful for creating custom installers and uninstallers in Powershell. The advantage to creating script installers versus uploading a regular exe or msi is that a script installer allows for fine-grained control over the installation process. This is especially useful when dealing with porly written installers.
At the end of this article, I will provide an exaple of a full script that can be used to install/uninstall a program."><meta property="og:type" content="article"><meta property="og:url" content="//localhost:1313/posts/sccm_powershell/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-07-11T00:00:00+00:00"><meta property="article:modified_time" content="2024-07-11T00:00:00+00:00"><meta property="og:site_name" content="Logan-Roelofs"><meta name=twitter:card content="summary"><meta name=twitter:title content="Useful Powershell Snippits to Create Custom Installers/Uninstallers"><meta name=twitter:description content="The Basics The following code snippets are useful for creating custom installers and uninstallers in Powershell. The advantage to creating script installers versus uploading a regular exe or msi is that a script installer allows for fine-grained control over the installation process. This is especially useful when dealing with porly written installers.
At the end of this article, I will provide an exaple of a full script that can be used to install/uninstall a program."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"//localhost:1313/posts/"},{"@type":"ListItem","position":2,"name":"Useful Powershell Snippits to Create Custom Installers/Uninstallers","item":"//localhost:1313/posts/sccm_powershell/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Useful Powershell Snippits to Create Custom Installers/Uninstallers","name":"Useful Powershell Snippits to Create Custom Installers\/Uninstallers","description":"The Basics The following code snippets are useful for creating custom installers and uninstallers in Powershell. The advantage to creating script installers versus uploading a regular exe or msi is that a script installer allows for fine-grained control over the installation process. This is especially useful when dealing with porly written installers.\nAt the end of this article, I will provide an exaple of a full script that can be used to install/uninstall a program.","keywords":[],"articleBody":" The Basics The following code snippets are useful for creating custom installers and uninstallers in Powershell. The advantage to creating script installers versus uploading a regular exe or msi is that a script installer allows for fine-grained control over the installation process. This is especially useful when dealing with porly written installers.\nAt the end of this article, I will provide an exaple of a full script that can be used to install/uninstall a program.\nSnippets Automagically Uninstall Programs # Retrieve uninstall information from the registry $programsToUninstall = Get-ChildItem -Path HKLM:\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Uninstall, HKLM:\\SOFTWARE\\Wow6432Node\\Microsoft\\Windows\\CurrentVersion\\Uninstall | # Extract properties of each registry key Get-ItemProperty | # Filter to only include items where the DisplayName matches \"Program Name\" Where-Object { ($_.DisplayName -match \"Program Name\")} | # Select the UninstallString and DisplayName for further processing Select-Object UninstallString, DisplayName This script will search the registry for installed programs that have a displayname that matches “Program Name” and return the uninstall string and display name for each program into the $programsToUninstall array. There is a few ways that we can expand this script to be more useful. For example,\nAdding a foreach loop to modify the uninstall string to include the /quiet or -s flag (depending on the program that we are unisntalling). This will allow us to silently uninstall the program. Add more Select-Object properties to the script to include the displayVersion of the program. This will allow us to create fine-grained uninstall scripts that can target specific versions of a program. Additionally, we can use this information to add to a custom log file. Error Handling When Calling External Programs try { # Running the msiexec program with example parameters $processInfo = Start-Process msiexec.exe -ArgumentList \"/i C:\\Path\\To\\Your\\Installer.msi /quiet /norestart\" -Wait -PassThru # Checking the exit code of the process if ($processInfo.ExitCode -eq 0) { Write-Host \"Installation succeeded without requiring a reboot.\" } elseif ($processInfo.ExitCode -eq 3010) { Write-Host \"Installation succeeded but a reboot is required.\" # Restart-Computer (restart the computer now) # $restart = $true (restart the computer later and using the $restart variable) } else { throw \"Installation failed with exit code $($processInfo.ExitCode).\" } } catch { # If an exception is thrown in the try block, it's caught here. Write-Host \"An error occurred: $_\" # Additional error handling can be performed here if needed. } The key takeaway from this script is the use of the try and catch blocks. The try block will attempt to run the code within the block. If an error occurs, the catch block will catch the error and run the code within the block. This is useful when calling external programs that may not return a 0 exit code when they run successfully. For example, the msiexec program will return a 0 exit code when it runs successfully, but it may return a 3010 exit code if a reboot is required. By using the try and catch blocks, we can catch the 3010 exit code and handle it accordingly.\nCommand Line Arguments param ( [string]$silent, [string]$uninstall ) Command line arguments can be passed to a Powershell script by using the param block at the beginning of the script. This block allows you to define the parameters that the script will accept. In this example, the script accepts two parameters: $silent and $uninstall. These parameters can be passed to the script when it is run from the command line. For example, .\\script.ps1 -silent \"true\" -uninstall \"true\".\nFull Example ","wordCount":"570","inLanguage":"en","datePublished":"2024-07-11T00:00:00Z","dateModified":"2024-07-11T00:00:00Z","mainEntityOfPage":{"@type":"WebPage","@id":"//localhost:1313/posts/sccm_powershell/"},"publisher":{"@type":"Organization","name":"","logo":{"@type":"ImageObject","url":"//localhost:1313/favicon.ico"}}}</script></head><body class=dark id=top><script>localStorage.getItem("pref-theme")==="light"&&document.body.classList.remove("dark")</script><header class=header><nav class=nav><div class=logo><div class=logo-switches><a href=//localhost:1313/ style=text-decoration:none><div class=logo><span class=logo__mark></span>
<span class=logo__text>Logan Roelofs</span>
<span class=logo__cursor></span></div></a><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=//localhost:1313/archives title=Blog><span>Blog</span></a></li><li><a href=//localhost:1313/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=//localhost:1313/about title=About><span>About</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">Useful Powershell Snippits to Create Custom Installers/Uninstallers</h1><div class=post-meta><span title='2024-07-11 00:00:00 +0000 UTC'>July 11, 2024</span></div></header><div class=post-content><hr><h2 id=the-basics>The Basics<a hidden class=anchor aria-hidden=true href=#the-basics>#</a></h2><p>The following code snippets are useful for creating custom installers and uninstallers in Powershell. The advantage to creating script installers versus uploading a regular exe or msi is that a script installer allows for fine-grained control over the installation process. This is especially useful when dealing with porly written installers.</p><p>At the end of this article, I will provide an exaple of a full script that can be used to install/uninstall a program.</p><hr><h2 id=snippets>Snippets<a hidden class=anchor aria-hidden=true href=#snippets>#</a></h2><h3 id=automagically-uninstall-programs>Automagically Uninstall Programs<a hidden class=anchor aria-hidden=true href=#automagically-uninstall-programs>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-powershell data-lang=powershell><span style=display:flex><span><span style=color:#75715e># Retrieve uninstall information from the registry</span>
</span></span><span style=display:flex><span>$programsToUninstall = Get-ChildItem -Path HKLM<span style=color:#960050;background-color:#1e0010>:</span>\SOFTWARE\Microsoft\Windows\CurrentVersion\Uninstall, HKLM<span style=color:#960050;background-color:#1e0010>:</span>\SOFTWARE\Wow6432Node\Microsoft\Windows\CurrentVersion\Uninstall |
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># Extract properties of each registry key</span>
</span></span><span style=display:flex><span>    Get-ItemProperty |
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># Filter to only include items where the DisplayName matches &#34;Program Name&#34;</span>
</span></span><span style=display:flex><span>    Where-Object { ($_.DisplayName <span style=color:#f92672>-match</span> <span style=color:#e6db74>&#34;Program Name&#34;</span>)} |
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># Select the UninstallString and DisplayName for further processing</span>
</span></span><span style=display:flex><span>    Select-Object UninstallString, DisplayName
</span></span></code></pre></div><p>This script will search the registry for installed programs that have a displayname that matches &ldquo;Program Name&rdquo; and return the uninstall string and display name for each program into the <code>$programsToUninstall</code> array. There is a few ways that we can expand this script to be more useful. For example,</p><ul><li>Adding a foreach loop to modify the uninstall string to include the <code>/quiet</code> or <code>-s</code> flag (depending on the program that we are unisntalling). This will allow us to silently uninstall the program.</li><li>Add more <code>Select-Object</code> properties to the script to include the <code>displayVersion</code> of the program. This will allow us to create fine-grained uninstall scripts that can target specific versions of a program. Additionally, we can use this information to add to a custom log file.</li></ul><h3 id=error-handling-when-calling-external-programs>Error Handling When Calling External Programs<a hidden class=anchor aria-hidden=true href=#error-handling-when-calling-external-programs>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-powershell data-lang=powershell><span style=display:flex><span><span style=color:#66d9ef>try</span> {
</span></span><span style=display:flex><span>    <span style=color:#75715e># Running the msiexec program with example parameters</span>
</span></span><span style=display:flex><span>    $processInfo = Start-Process msiexec.exe -ArgumentList <span style=color:#e6db74>&#34;/i C:\Path\To\Your\Installer.msi /quiet /norestart&#34;</span> -Wait -PassThru
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># Checking the exit code of the process</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> ($processInfo.ExitCode <span style=color:#f92672>-eq</span> <span style=color:#ae81ff>0</span>) {
</span></span><span style=display:flex><span>        Write-Host <span style=color:#e6db74>&#34;Installation succeeded without requiring a reboot.&#34;</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>elseif</span> ($processInfo.ExitCode <span style=color:#f92672>-eq</span> <span style=color:#ae81ff>3010</span>) {
</span></span><span style=display:flex><span>        Write-Host <span style=color:#e6db74>&#34;Installation succeeded but a reboot is required.&#34;</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e># Restart-Computer (restart the computer now)</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e># $restart = $true (restart the computer later and using the $restart variable)</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>throw</span> <span style=color:#e6db74>&#34;Installation failed with exit code </span>$($processInfo.ExitCode)<span style=color:#e6db74>.&#34;</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#66d9ef>catch</span> {
</span></span><span style=display:flex><span>    <span style=color:#75715e># If an exception is thrown in the try block, it&#39;s caught here.</span>
</span></span><span style=display:flex><span>    Write-Host <span style=color:#e6db74>&#34;An error occurred: </span>$_<span style=color:#e6db74>&#34;</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># Additional error handling can be performed here if needed.</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>The key takeaway from this script is the use of the <code>try</code> and <code>catch</code> blocks. The <code>try</code> block will attempt to run the code within the block. If an error occurs, the <code>catch</code> block will catch the error and run the code within the block. This is useful when calling external programs that may not return a 0 exit code when they run successfully. For example, the <code>msiexec</code> program will return a 0 exit code when it runs successfully, but it may return a 3010 exit code if a reboot is required. By using the <code>try</code> and <code>catch</code> blocks, we can catch the 3010 exit code and handle it accordingly.</p><h3 id=command-line-arguments>Command Line Arguments<a hidden class=anchor aria-hidden=true href=#command-line-arguments>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-powershell data-lang=powershell><span style=display:flex><span><span style=color:#66d9ef>param</span> (
</span></span><span style=display:flex><span>    [<span style=color:#66d9ef>string</span>]$silent,
</span></span><span style=display:flex><span>    [<span style=color:#66d9ef>string</span>]$uninstall
</span></span><span style=display:flex><span>)
</span></span></code></pre></div><p>Command line arguments can be passed to a Powershell script by using the <code>param</code> block at the beginning of the script. This block allows you to define the parameters that the script will accept. In this example, the script accepts two parameters: <code>$silent</code> and <code>$uninstall</code>. These parameters can be passed to the script when it is run from the command line. For example, <code>.\script.ps1 -silent "true" -uninstall "true"</code>.</p><h2 id=full-example>Full Example<a hidden class=anchor aria-hidden=true href=#full-example>#</a></h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-powershell data-lang=powershell></code></pre></div><hr><script src=https://giscus.app/client.js data-repo=jpmcb/blog data-repo-id="MDEwOlJlcG9zaXRvcnkxMTYxODMyNjg=" data-category="Blog comments" data-category-id=DIC_kwDOBuzQ5M4CTbHW data-mapping=pathname data-strict=0 data-reactions-enabled=1 data-emit-metadata=0 data-input-position=top data-theme=dark_dimmed data-lang=en data-loading=lazy crossorigin=anonymous async></script></div><footer class=post-footer><ul class=post-tags></ul></footer></article></main><footer class=footer><span>&copy; 2024 <a href=//localhost:1313/></a></span><span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>